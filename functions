######################################################################
##############     Useful functions for CTRI Reports     #############
######################################################################


pvalFormat <- function(p.values, method = 'none', replace = FALSE, math = TRUE){
    ## Formats p-values for reports, can report adjusted pvalues
    ##    Inputs:
    ##       - p.value: numeric p-value
    ##       - method: pvalue adjustment, passed to p.adjust.methods
    ##       - replace: if TRUE, replaces p-values with their adjusted value
    ##    Outputs:
    ##       - out: formatted p-value
    
    p.values <- suppressWarnings(as.numeric(p.values))
    out      <- rep(NA, length(p.values))
    sig      <- p.adjust(p.values, method)
    if(replace) p.values <- sig
    
    for(i in 1:length(p.values)){
        if(is.na(p.values[i])){out[i] <- NA}else{
            if(p.values[i] >= .001){
                out[i] <- paste('$', formatC(p.values[i], format = 'f', digits = 3), '$', sep = '')
            }
            
            if(p.values[i] < .001){
                out[i] <- '< $0.001$'
            }
            
            if(sig[i] > 0.01 & sig[i] <= 0.05){
                out[i] <- paste(out[i], '*', sep = '')
            }
            
            if(sig[i] > 0.001 & sig[i] <= 0.01) {
                out[i] <- paste(out[i], '**', sep = '')
            }
            
            if(sig[i] <= 0.001){
                out[i] <- paste(out[i], '***', sep = '')
            }}
    }
    
    out[is.na(out)] <- '-'
    return(out)
}


######################################################################
######################################################################
######################################################################
######################################################################


logitLatex <- function(mod, VAR = NULL, CAPTION = NULL, tex = TRUE){
    ## Used for printing glm(...) logistic regression outputs, to be expanded for glmm(...), etc
    ##    Inputs:
    ##       - mod: logistic regression, fit by glm()
    ##       - VAR: Variable names (for aesthetics, rownames for the matrix that gets passed to latex(...))
    ##       - CAPTION: Caption to be passed to latex(...)
    ##    Output:
    ##       - MAT: table ready for <<results = tex>> environment
    ##
    ## Note: OR's are computed by profile likelihood, may not agree w/ p-values from regression.
    ##       Also requires pvalFormat(...) function
    
    logitPrint <- function(mod, rnames = NULL){
        MAT        <- cbind(summary(mod)$coefficients, logitOR(mod))
        MAT[, 1:3] <- paste('$', formatC(as.numeric(MAT[, 1:3]), format = 'f', digits = 3), '$', sep = '')
        MAT[, 4]   <- pvalFormat(MAT[, 4])
        if(!is.null(rnames)) rownames(MAT)[2:nrow(MAT)] <- rnames
        colnames(MAT)[5:6] <- c('Odds Ratio', '95\\% CI')
        MAT[1, 5:6] <- c('-', '-')
        MAT <- rbind(rep('', ncol(MAT)), MAT)
        rownames(MAT)[1] <- '{\\bf Covariates}'
        rownames(MAT)[2:nrow(MAT)] <- paste('~~~~', rownames(MAT)[2:nrow(MAT)], sep = '')
        return(MAT)
    }
    
    logitOR <- function(mod){
        CI <- exp(cbind(OR = coef(mod), confint.default(mod)))
        cbind(paste('$', formatC(CI[, 1], format = 'f', digits = 3), '$', sep = ''),
              paste('($', formatC(CI[, 2], format = 'f', digits = 3), '$, $',
                    formatC(CI[, 3], format = 'f', digits = 3), '$)', sep = ''))
    }
    if(tex){
    latex(logitPrint(mod, VAR),
          file = '',
          title = '',
          col.just = c('r', 'r', 'r', 'r', 'r', 'c'),
          where = '!hbp',
          caption = CAPTION)} else{
            dd <- gsub('$', '', logitPrint(mod, VAR), fixed = T)
            return(dd)
          }
}


######################################################################
######################################################################
######################################################################
######################################################################


CI_cont <- function(x, conf = .95, ...){
    x_bar <- mean(x, ...)
    sd_bar <- sd(x, ...)
    nn <- sum(!is.na(x))
    SE <- qt(conf + (1 - conf) / 2, df = nn - 1) * sd_bar / sqrt(nn)
    out <- x_bar + c(-1, 1) * SE
    return(out)
}


######################################################################
######################################################################
######################################################################
######################################################################


se <- function(x, ...) sqrt(var(x, ...)/sum(!is.na(x)))


######################################################################
######################################################################
######################################################################
######################################################################


demoTab <- function(vars, group = NULL, data, overall = TRUE, show.na = TRUE, show.totals = T, digits = 2,
                    tests = NULL, test.args = NULL, test.stat = F,
                    con.tests = NULL, con.test.args = NULL,
                    cat.tests = NULL, cat.test.args = NULL,
                    cent.funs = NULL, cent.args = NULL,
                    var.funs = NULL, var.args = NULL, 
                    rnames = NULL, bold = F,
                    tex = TRUE, add.space = FALSE,
                    save.tests = F, out.name = NULL, 
                    csv = F, csv.name = NULL, 
                    print = T, ...){
  ## A function to create standard demographics tables.
  ##    Inputs:
  ##       - vars: a character or numeric vector indicating the data columns of interest.
  ##               Also accepts a formula object, similar to summary.formula. To have a single group,
  ##               use something like: ". ~ Var1 + Var2 + etc...".
  ##       - group: a character or numeric vector indicating the groups, if any, to analyze.
  ##       - data: data set.
  ##       - overall: Logical, should an overall column be included?      
  ##       - show.na: Logical, should NA values be shown for categorical variables?
  ##       - show.totals: Logical, should the sample sizes be reported for each variable (i.e. number of non-NA values).
  ##       - tests: character vector of tests to do for each variable, ie. c('fisher.test', 'fisher.test', 'wilcox.test', 't.test', etc...).
  ##       - tests.args: list (of lists) of arguments to pass to each significance test.
  ##       - con.tests: character string, alternative way to specify tests to be done for all continuous variables.
  ##       - con.test.args: list (of lists), alternative way to specify arguments to pass to each significance test.
  ##       - cat.tests: character string, alternative way to specify tests to be done for all categorical variables.
  ##       - cat.test.args: list (of lists), alternative way to specify arguments to pass to each significance test.
  ##       - cent.funs: list of functions to report for measures of central tendency (i.e. mean vs median). Categorical data is only
  ##                    reported as count (percentage) currently.
  ##       - cent.args: list (of lists) of arguments to pass to the above central tendency functions.
  ##       - var.funs: list of functions to report for measures of variation (i.e. standard deviation vs range).
  ##       - var.args: list of (of lists) arguments to pass to the above variation functions.
  ##       - rnames: character vector to replace the row names of the final table.
  ##       - bold: Logical, should the row names be bold in LaTeX?
  ##       - tex: Logical, should the output be read for latex(...) (i.e. math environment included throughout).
  ##       - add.space: Logical, should a line of space be added between each variable?
  ##       - save.tests: Logical, should the statistical tests be saved in a seperate list?
  ##       - out.name: character string, object to save test output to?
  ##       - csv: Logical, should a .csv of the table be printed?
  ##       - csv.name: character string, name / directory to print the .csv file.
  ##       - print: Logical, should the table object be saved in R (should almost always be TRUE).
  
  makeTab <- function(X, GRPS, TEST, TEST.ARG, CENT.FUN, CENT.ARG, VAR.FUN, VAR.ARG, digits, show.na, ...){
    
    fun_switcher <- function(XX, FUN = NULL, ARG = NULL, digits = digits, v.Fun = F){
      if(FUN %in% c('median', 'mean', 'var', 'sd', 'range', 'IQR', 'quantile', 'CI_cont', 'se')){
        if(FALSE){#!is.null(ARG)){
          AARG <- vector('list', length(ARG) + 1)
          for(i in 1:length(ARG)) AARG[[i]] <- ARG[[i]]
          AARG[[length(AARG)]] <- XX
          names(AARG) <- c(names(ARG), 'x')
          ARG <- AARG
        }
        ARG[[length(ARG) + 1]] <- XX
        names(ARG)[length(ARG)] <- 'x'
        out <- do.call(FUN, ARG)
      } else{
        out <- switch(FUN
                      ## Space set here to add in additional functions with different
                      ## argument forms (ie main argument isn't called 'x')
        )
      }
      if(length(out) == 1 & !v.Fun){
        out2 <- paste('$', formatC(out, format = 'f', digits), '$', sep = '')
      }
      if(length(out) == 1 & v.Fun){
        out2 <- paste('($', formatC(out, format = 'f', digits), '$)', sep = '')
      }
      if(length(out) == 2){
        out2 <- paste('($', formatC(out[1], format = 'f', digits), '$, $',
                      formatC(out[2], format = 'f', digits), '$)', sep = '')
      }
      out2
    }        
    
    test_switcher <- function(XX, GRPS, TEST = NULL, TEST.ARG = NULL){
      switch(TEST,
             t.test       = {TEST.ARG[[length(TEST.ARG) + 1]] <- XX[GRPS == unique(GRPS)[!is.na(unique(GRPS))][1]]
             TEST.ARG[[length(TEST.ARG) + 1]] <- XX[GRPS == unique(GRPS)[!is.na(unique(GRPS))][2]]
             names(TEST.ARG)[c(length(TEST.ARG) - 1, length(TEST.ARG))] <- c('x', 'y')
             temp <- do.call(TEST, TEST.ARG)
             out <- list(temp$p.value, temp, 
                         paste('$t_{', round(temp$parameter, 1), '} = ', formatC(temp$statistic, format = 'f', digits = 3), '$', sep = ''))},
             
             wilcox.test  = {TEST.ARG[[length(TEST.ARG) + 1]] <- XX[GRPS == unique(GRPS)[!is.na(unique(GRPS))][1]]
             TEST.ARG[[length(TEST.ARG) + 1]] <- XX[GRPS == unique(GRPS)[!is.na(unique(GRPS))][2]]
             names(TEST.ARG)[c(length(TEST.ARG) - 1, length(TEST.ARG))] <- c('x', 'y')
             temp <- do.call(TEST, TEST.ARG)
             out <- list(temp$p.value, temp,
                         paste('$', names(temp$statistic), ' = ', formatC(temp$statistic, format = 'f', digits = 0), '$', sep = ''))},
             
             kruskal.test = {TEST.ARG[[length(TEST.ARG) + 1]] <- XX
             TEST.ARG[[length(TEST.ARG) + 1]] <- as.numeric(factor(GRPS))
             names(TEST.ARG)[c(length(TEST.ARG) - 1, length(TEST.ARG))] <- c('x', 'g')
             temp <- do.call(TEST, TEST.ARG)
             out <- list(temp$p.value, temp, paste('$H = ', formatC(temp$statistic, format = 'f', digits = 3), '$', sep = ''))},
             
             anova        = {TEST.ARG[[length(TEST.ARG) + 1]] <- lm(XX[!is.na(GRPS)] ~ GRPS[!is.na(GRPS)])
             TEST.ARG[[length(TEST.ARG) + 1]] <- lm(XX[!is.na(GRPS)] ~ 1)
             names(TEST.ARG)[length(TEST.ARG) - 1] <- 'object'
             temp <- do.call(TEST, TEST.ARG)
             if(names(temp)[5] == 'F'){out <- list(temp$Pr[2], temp, paste('$F_{', temp[1, 'Res.Df'], '}^{', abs(temp[2, 'Df']), '} = ', 
                                                                           formatC(temp$F[2], format = 'f', digits = 3), '$', sep = ''))}
             if(names(temp)[5] == 'Pr(>Chi)'){
               out <- list(temp$Pr[2], temp, paste('$\\chi_{', abs(temp[2, 'Df']), '}^{2} = ', 
                                                   formatC((temp[2, 4] / temp[2, 3]) / (temp[1, 2] / temp[1, 1]), format = 'f', digits = 3), '$', sep = ''))}
             if(names(temp)[5] == 'Cp'){out <- list('-', temp, paste('$C_p = ', formatC(temp[1, 5], format = 'f', digits = 3), '$', sep = ''))}},
             
             chisq.test   = {TEST.ARG[[length(TEST.ARG) + 1]] <- XX
             TEST.ARG[[length(TEST.ARG) + 1]] <- GRPS
             names(TEST.ARG)[c(length(TEST.ARG) - 1, length(TEST.ARG))] <- c('x', 'y')
             temp <- do.call(TEST, TEST.ARG)
             out <- list(temp$p.value, temp, paste('$\\chi_{', temp$parameter, '}^{2} = ', formatC(temp$statistic), '$', sep = ''))},
             
             fisher.test  = {TEST.ARG[[length(TEST.ARG) + 1]] <- XX
             TEST.ARG[[length(TEST.ARG) + 1]] <- GRPS
             names(TEST.ARG)[c(length(TEST.ARG) - 1, length(TEST.ARG))] <- c('x', 'y')
             temp <- do.call(TEST, TEST.ARG)
             out <- list(temp$p.value, temp, '-')},
             
             none         = {out <- list('-', '-', '-')}
             
             ## Additional tests can be added here
      )
      out[[1]] <- pvalFormat(out[[1]])
      out
    }           
    
    if(class(X) %in% c('numeric', 'integer')){
      if(is.null(CENT.FUN)) CENT.FUN <- 'mean'
      if(is.null(CENT.ARG)) CENT.ARG <- list(na.rm = TRUE)
      if(is.null(VAR.FUN))  VAR.FUN  <- 'sd'
      if(is.null(VAR.ARG))  VAR.ARG  <- list(na.rm = TRUE)
      if(!is.null(GRPS)){
        if(is.null(TEST) & length(unique(GRPS)[!is.na(unique(GRPS))]) == 2) TEST <- 't.test'
        if(is.null(TEST) & length(unique(GRPS)[!is.na(unique(GRPS))]) > 2)  TEST <- 'anova'
        outLine <- matrix(nrow = 1, ncol = length(unique(GRPS)[!is.na(unique(GRPS))]) + 1); K = 1
        for(j in sort(unique(GRPS)[!is.na(unique(GRPS))])){
          XX <- X[GRPS %in% j]
          outLine[1, K] <- paste(fun_switcher(XX, CENT.FUN, CENT.ARG, digits),
                                 fun_switcher(XX, VAR.FUN, VAR.ARG, digits, v.Fun = T))
          K = K + 1
        }
        outLine[1, ncol(outLine)] <- paste(fun_switcher(X[!is.na(GRPS)], CENT.FUN, CENT.ARG, digits),
                                           fun_switcher(X[!is.na(GRPS)], VAR.FUN, VAR.ARG, digits, v.Fun = T))
        tList <- try(test_switcher(X, GRPS, TEST, TEST.ARG))
        if (class(tList) == 'try-error') {tList <- list('-', '-', '-')}
        if(test.stat){outLine <- cbind(outLine, tList[[3]], tList[[1]])} else{outLine <- cbind(outLine, tList[[1]])}
        test_holder[[i]] <<- tList[[2]]
      } else{
        outLine <- matrix(nrow = 1, ncol = 1)
        outLine[1, 1] <- paste(fun_switcher(X, CENT.FUN, CENT.ARG, digits),
                               fun_switcher(X, VAR.FUN, VAR.ARG, digits, v.Fun = T))
      }
    }
    
    if(class(X) %in% c('character', 'factor', 'logical')){
      if(is.null(GRPS)){
        if(show.na){
          FF <- X
          suppressWarnings(FF[is.na(FF)] <- 'NA')
          outLine <- as.matrix(suppressWarnings(paste('$', table(FF), '$ ($',
                                                      formatC(prop.table(table(FF)) * 100, digits = 1, format = 'f'), '\\%$', ')', sep = '')),
                               ncol = 1)    
          if('NA' %in% rownames(table(FF))){
            outLine1 <- outLine
            outLine <- outLine[-which(rownames(table(FF)) == 'NA'), , drop = F]
            outLine <- rbind(outLine, outLine1[which(rownames(table(FF)) == 'NA'), ])
          }          
        } else{
          outLine <- as.matrix(suppressWarnings(paste('$', table(X), '$ ($',
                                                      formatC(prop.table(table(X)) * 100, digits = 1, format = 'f'), '\\%$', ')', sep = '')),
                               ncol = 1)    
        }
        outLine <- rbind(rep('', ncol(outLine)), outLine)
      } else{
        if(is.null(TEST)) TEST <- 'chisq.test'
        if(show.na){
          FF <- X
          suppressWarnings(FF[is.na(FF)] <- 'NA')
          outLine <- paste('$', table(FF, GRPS), '$ ($',
                           suppressWarnings(formatC(prop.table(table(FF, GRPS), margin = 2) * 100, 
                                                    digits = 1, format = 'f')), '\\%', '$)', sep = '')
          outLine <- cbind(matrix(outLine, ncol = length(unique(GRPS)[!is.na(unique(GRPS))])),
                           paste('$', table(FF), '$ ($',
                                 suppressWarnings(formatC(prop.table(table(FF)) * 100, digits = 1, format = 'f')), '\\%', '$)', sep = ''))
          if('NA' %in% rownames(table(FF, GRPS))){
            outLine1 <- outLine
            outLine <- outLine[-which(rownames(table(FF, GRPS)) == 'NA'), ]
            outLine <- rbind(outLine, outLine1[which(rownames(table(FF, GRPS)) == 'NA'), ])
          }
        } else{
          outLine <- paste('$', table(X, GRPS), '$ ($',
                           suppressWarnings(formatC(prop.table(table(X, GRPS), margin = 2) * 100, 
                                                    digits = 1, format = 'f')), '\\%', '$)', sep = '')
          outLine <- suppressWarnings(cbind(matrix(outLine, ncol = length(unique(GRPS)[!is.na(unique(GRPS))])),
                                            paste('$', table(X), '$ ($',
                                                  formatC(prop.table(table(X)) * 100, digits = 1, format = 'f'), '\\%', '$)', sep = '')))
        }
        
        if(nrow(outLine) != 1){
          tList <- try(test_switcher(X, GRPS, TEST, TEST.ARG))
          if (class(tList) == 'try-error') {tList <- list('-', '-', '-')}
          p.test <- tList[[1]]
          test_holder[[i]] <<- tList[[2]]
        } else{
          p.test <- c('-')
        }
        outLine <- rbind(rep('', ncol(outLine)), outLine)
        if(test.stat){
          outLine <- cbind(outLine, c('', tList[[3]], rep('', nrow(outLine) - 2)), c('', p.test, rep('', nrow(outLine) - 2)))
        } else{outLine <- cbind(outLine, c('', p.test, rep('', nrow(outLine) - 2)))}
      }
    }
    
    if(!tex){
      outLine <- gsub('$', '', outLine, fixed = T)
      outLine <- gsub('\\;', '', outLine, fixed = T)
      outLine <- gsub('\\', '', outLine, fixed = T)
    }
    return(outLine)
  }
  
  ## Defines grouping variable / variables of interest
  if(!is.null(group)){
    if(class(group) %in% c('factor', 'character', 'logical')) GROUPS <- which(names(data) == group)
    if(class(group) %in% c('integer', 'numeric')) GROUPS <- group
  } else{GROUPS <- NULL}
  
  if(!class(vars) %in% c('formula', 'factor', 'character', 'integer', 'numeric')) stop('Unsupported class for vars argument.')
  
  if(class(vars) == 'formula'){
    if(as.character(vars[2]) == '.') GROUPS <- NULL else{GROUPS <- which(names(data) == as.character(vars[2]))}
    VAR_NAMES <- strsplit(as.character(vars[3]), ' + ', fixed = TRUE)[[1]]
    WHICH <- numeric(length(VAR_NAMES))
    for(ii in 1:length(WHICH)) WHICH[ii] <- which(names(data) == VAR_NAMES[ii])
  }
  
  if(class(vars) %in% c('character', 'factor', 'logical')) WHICH <- sapply(1:length(vars), function(x) which(names(data) == vars[x]))
  if(class(vars) %in% c('integer', 'numeric'))  WHICH <- vars
  
  if(!is.null(GROUPS)) GRPS <- data[, GROUPS] else{GRPS <- NULL}
  
  ## Matrix of non-NA values.
  SS = suppressWarnings(matrix(nrow = length(WHICH), ncol = length(unique(GRPS)[!is.na(unique(GRPS))]) + 1))
  for(i in 1:length(WHICH)){
    if(!is.null(GRPS)){
      SS[i, ] <- c(tapply(data[, WHICH[i]], GRPS, function(x) sum(!is.na(x))), sum(tapply(data[, WHICH[i]], GRPS, function(x) sum(!is.na(x)))))
    }
    if(is.null(GRPS)){
      SS[i, ] <- sum(!is.na(data[, WHICH[i]]))
    }
  }
  
  ## Filling in test arguments and centrality / variance functions
  kk = 1
  if(!is.null(con.tests)){
    tests <- rep(NA, length(WHICH))
    for(i in 1:length(tests)){
      if(class(data[, WHICH[i]]) %in% c('numeric', 'integer')){
        tests[i] <- con.tests[kk]
        if(length(con.tests) > 1) kk = kk + 1
      }
      if(class(data[, WHICH[i]]) %in% c('character', 'factor', 'logical') & is.null(cat.tests)) tests[i] <- 'chisq.test'
    }
  }
  
  kk = 1
  if(!is.null(cat.tests)){
    if(is.null(tests)) tests <- rep(NA, length(WHICH))
    for(i in 1:length(tests)){
      if(class(data[, WHICH[i]]) %in% c('numeric', 'integer') & is.null(con.tests)) tests[i] <- 't.test'
      if(class(data[, WHICH[i]]) %in% c('character', 'factor', 'logical')){
        tests[i] <- cat.tests[kk]
        if(length(cat.tests) > 1) kk = kk + 1
      }
    }
  }
  
  kk = 1
  if(!is.null(con.test.args)){
    test.args <- list()
    for(i in 1:length(WHICH)){
      if(class(data[, WHICH[i]]) %in% c('numeric', 'integer')){
        test.args[[i]] <- con.test.args[[kk]]
        if(length(con.test.args) > 1) kk = kk + 1
      }
      if(class(data[, WHICH[i]]) %in% c('character', 'factor', 'logical') & is.null(cat.test.args)) test.args[[i]] <- list()
    }
  }
  
  kk = 1
  if(!is.null(cat.test.args)){
    if(is.null(tests)) test.args <- list()
    for(i in 1:length(WHICH)){
      if(class(data[, WHICH[i]]) %in% c('numeric', 'integer') & is.null(con.tests)) test[[i]] <- list()
      if(class(data[, WHICH[i]]) %in% c('character', 'factor', 'logical')){
        test.args[[i]] <- cat.test.args[[kk]]
        if(length(cat.test.args) > 1) kk = kk + 1
      }
    }
  }
  
  if(sum(sapply(WHICH, function(x) class(data[, x])) %in% c('numeric', 'integer')) > 1 & length(cent.funs) == 1) {
    cent.funs <- rep(cent.funs, length(WHICH))
  }
  
  if(sum(sapply(WHICH, function(x) class(data[, x])) %in% c('numeric', 'integer')) > 1 & length(cent.args) == 1) {
    cent.args <- rep(cent.args, length(WHICH))
  }
  
  if(sum(sapply(WHICH, function(x) class(data[, x])) %in% c('numeric', 'integer')) > 1 & length(var.funs) == 1) {
    var.funs <- rep(var.funs, length(WHICH))
  }
  
  if(sum(sapply(WHICH, function(x) class(data[, x])) %in% c('numeric', 'integer')) > 1 & length(var.args) == 1) {
    var.args <- rep(var.args, length(WHICH))
  }
  
  sample.sizes <- cbind(matrix(paste('$n = ', SS, '$', sep = ''), nrow = nrow(SS)), rep('', nrow(SS)))
  if(is.null(GRPS)) sample.sizes <- matrix(paste('$n=', SS, '$', sep = ''), nrow = nrow(SS))
  diff.totals = any(apply(SS, MARGIN = 2, function(x) length(unique(x))) > 1)
  dTab <- NULL    
  test_holder <- list()
  for(i in 1:length(WHICH)){
    tOut <- makeTab(data[, WHICH[i]], GRPS, tests[i], test.args[[i]], cent.funs[i], cent.args[[i]], var.funs[i], var.args[[i]], digits, show.na = show.na)
    if(class(data[, WHICH[i]]) %in% c('integer', 'numeric')){
      rownames(tOut) <- names(data)[WHICH[i]]
      if(diff.totals & show.totals){
        SSNAMES <- paste('$n = ', SS[i, ], '$', sep = '')
        if(!is.null(GRPS)) SSNAMES <- c(SSNAMES, '')
        tOut <- rbind(SSNAMES, tOut)
        rownames(tOut) <- c(names(data)[WHICH[i]], '')
      }
    }
    if(class(data[, WHICH[i]]) %in% c('character', 'factor', 'logical')){
      RNAMES <- c(names(data)[WHICH[i]], paste('~~~~', sort(unique(data[, WHICH[i]])[!is.na(unique(data[, WHICH[i]]))]), sep = ''))
      if(nrow(tOut) == length(RNAMES)){
        rownames(tOut) <- RNAMES
      } else{rownames(tOut) <- c(RNAMES, '~~~~NA')}
      if(diff.totals & show.totals){
        tOut[1, 1:(ncol(tOut) - 1)] <- paste('$n = ', SS[i, ], '$', sep = '')
      }
    }
    dTab <- rbind(dTab, tOut)
    if(add.space & i != length(WHICH)) dTab <- rbind(dTab, rep('', ncol(dTab)))
  }
  
  if(is.null(GRPS)){
    if(!diff.totals & show.totals){
      colnames(dTab) <- paste('Overall ($n = ', SS[1, 1], '$)', sep = '')
    }
    if(!diff.totals & !show.totals){
      colnames(dTab) <- 'Overall' 
    }
    if(diff.totals){
      colnames(dTab) <- 'Overall'
    }
  } else{
    if(!diff.totals & show.totals){
      if(test.stat){
        colnames(dTab) <- c(paste(c(as.character(sort(unique(GRPS)[!is.na(GRPS)])), 'Overall'),
                                  ' ($n = ', SS[1, ], '$)', sep = ''), '', 'p-value')
      } else{
        colnames(dTab) <- c(paste(c(as.character(sort(unique(GRPS)[!is.na(GRPS)])), 'Overall'),
                                  ' ($n = ', SS[1, ], '$)', sep = ''), 'p-value')}
    }
    if(!diff.totals & !show.totals){
      if(test.stat){
        colnames(dTab) <- c(as.character(sort(unique(GRPS)[!is.na(GRPS)])), 'Overall', '', 'p-value')
      } else{
        colnames(dTab) <- c(as.character(sort(unique(GRPS)[!is.na(GRPS)])), 'Overall', 'p-value')}
    }
    if(diff.totals){
      if(test.stat){
        colnames(dTab) <- c(as.character(sort(unique(GRPS)[!is.na(GRPS)])), 'Overall', '', 'p-value')
      } else{
        colnames(dTab) <- c(as.character(sort(unique(GRPS)[!is.na(GRPS)])), 'Overall', 'p-value')}
    }
  }
  if(!is.null(GRPS) & !overall) dTab <- dTab[, -which(substr(colnames(dTab), 0, 7) == 'Overall')]
  if(save.tests){
    if(is.null(out.name)){
      warning('No out.name entered - saving test list as DEMOTAB_TESTS\n')
      out.name <- 'DEMOTAB_TESTS'
    }
    assign(out.name, test_holder, envir = .GlobalEnv)
  }
  if(csv){
    if(is.null(csv.name)){
      warning('No csv.name entered - saving csv to current directly as DTAB.csv')
      csv.name <- 'DTAB.csv'
    }
    aTab <- gsub('$', '', gsub('\\', '', dTab, fixed = T), fixed = T)
    colnames(aTab) <- gsub('$', '', colnames(dTab), fixed = T)
    write.csv(dTab, file = csv.name)
  } 
  dTab[which(dTab == "$0$ ($NaN\\%$)")] <- '$0$ (-)'
  if(!is.null(rnames)) rownames(dTab)[!substr(rownames(dTab), 1, 1) %in% c('~', '')] <- rnames
  if(bold) rownames(dTab)[!substr(rownames(dTab), 1, 1) %in% c('~', '')] <- paste('{\\bf ', rownames(dTab)[!substr(rownames(dTab), 1, 1) %in% c('~', '')], '}', sep = '')
  if(print) return(dTab)
}


######################################################################
######################################################################
######################################################################
######################################################################


clustered_ranksum <- function(x, grps, clusts){
    ## Based on Datta, Somnath and Satten, Glen 'Rank-Sum Tests for Clustered Data' (2005),
    ## computes a rank-sum test for clustered data. This function needs to be tested, LZ screwed it up
    ## Null Hypothesis: Observations from two groups follow the same distribution
    ##    Inputs:
    ##       - x: observations
    ##       - grps: group membership (two groups supported currently)
    ##       - clust: cluster identifier
    ##    Outputs:
    ##       - test statistic and pvalue?
    
    grps <- as.numeric(grps); clusts <- as.character(clusts)
    M <- length(unique(clusts))
    
    ## Computing E(S) under the null
    E_S <- .5 * sum(tapply(grps, clusts, function(x) sum(x == 1) / length(x)))
    
    ## Computing S
    F_i <- function(X, i, left_lim = FALSE){
        if(!left_lim){
            1 / sum(clusts == unique(clusts)[i]) * sum(x[clusts == unique(clusts)[i]] <= X)
        } else{
            1 / sum(clusts == unique(clusts)[i]) * sum(x[clusts == unique(clusts)[i]] < X)            
        }
    }
    
    wrapr <- function(X, i){
        sto <- numeric(M)
        for(j in 1:M){
            if(j != i) sto[j] <- F_i(X, j) + F_i(X, j, left_lim = TRUE) 
        }
        sum(sto)
    }
    
    outer <- numeric(M)
    for(i in 1:M){
        ind   <- clusts == unique(clusts)[i]
        inner <- numeric(sum(ind))
        for(k in 1:sum(ind)){
            inner[k] <- grps[ind][k] / sum(ind) * (1 + .5 * wrapr(x[ind][k], i))
        }
        outer[i] <- sum(inner)
    }
    
    S <- 1 / (M + 1) * sum(outer)

    ## Computing Var(S)
    
    E_W <- function(i){
        ind <- clusts == unique(clusts)[i]
        M / (2 * M + 2) * (sum(grps[ind]) / sum(ind) - mean(tapply(grps, clusts, function(x) sum(x) / length(x))))
    }
    
    F_hat <- function(X, left_lim = FALSE){
        top <- numeric(M)
        for(i in 1:M) top[i] <- table(clusts)[i] * F_i(X, i, left_lim)
        sum(top) / length(x)
    }
    
    W_i_hat <- function(i){
        ind <- clusts == unique(clusts)[i]        
        p1 <- 1 / (2 * sum(ind) * (M + 1))
        sto <- numeric(sum(ind))
        for(k in 1:sum(ind)){
            sum1 <- tapply(grps, clusts, function(x) sum(x) / length(x))
            sum1[i] <- 0
            p2     <- (M - 1) * grps[ind][k] - sum(sum1)
            sto[k] <- p2 * (F_hat(x[ind][k]) + F_hat(x[ind][k], left_lim = TRUE))
        }
        p1 * sum(sto)
    }
    
    sto <- numeric(M)
    for(i in 1:M) sto[i] <- (W_i_hat(i) - E_W(i)) ^ 2
    Var_S <- sum(sto)
    
    ## Computing the test statisic
    Z <- (S - E_S) / sqrt(Var_S)
    p.val <- 2 * (1 - pnorm(abs(Z)))
    out <- c(Z, p.val)
    names(out) <- c('Z', 'p-value')
    return(out)
}


######################################################################
######################################################################
######################################################################
######################################################################


preamble.ucsd <- function(title = "Main Title", type = "Report type", 
                          authors = list(Investigators = c("investigator name 1", "investigator name 2"), Analyst = c("analyst name")), 
                          date = "\\today", 
                          logo = file.path("/Users", "jproudfoot", "Desktop", "CTRI", "CTRI.pdf"), 
                          tableofcontents = TRUE, Sweave = file.path(R.home("share"), "texmf", "tex", "latex", "Sweave"), 
                          titlefooter = NULL, preamble = NULL){
  authors1 <- cbind("", paste("&", unlist(authors), "\\\\ "))
  authors1[cumsum(c(1, unlist(lapply(authors, length))))[-(length(authors) + 
                                                             1)], 1] <- paste(names(authors), ":", sep = "")
  authors1 <- paste(t(authors1), collapse = "")
  cat(paste(
    "
    \\documentclass{article}
    
    \\usepackage[utf8x]{inputenc}
    \\renewcommand{\\familydefault}{\\sfdefault}
    \\usepackage{graphicx}
    \\usepackage{xcolor}
    \\usepackage{fancyhdr}
    \\usepackage{colortbl}
    \\usepackage{verbatim}
    \\usepackage{listings}
    \\usepackage{booktabs}
    \\usepackage{alltt}
    \\usepackage{amsmath, amsfonts, amssymb}
    \\lstset{breaklines = true, numbers = left, numberstyle = \\scriptsize\\ttfamily, numbersep = 10pt, 
    captionpos = b, backgroundcolor = \\color{gray!10}, framesep = 4pt}
    \\usepackage{", Sweave, "}
    \\RequirePackage[pdftex, pdfpagemode = none, \n    pdftoolbar = true, pdffitwindow = true, \n    pdfcenterwindow = true]{hyperref}
    
    \\hypersetup{\n    pdfborder = {0 0 0}\n}
    
    \\IfFileExists{mathpazo.sty}{\\RequirePackage[osf,sc]{mathpazo}}{}
    \\IfFileExists{helvet.sty}{\\RequirePackage[scaled=1]{helvet}}{}
    \\IfFileExists{beramono.sty}{\\RequirePackage[scaled=1]{beramono}}{}
    \\RequirePackage[T1]{fontenc}
    \\RequirePackage{textcomp}
    
    \\definecolor{Blue}{rgb}{0, 0.140625, 0.36328125}
    \\definecolor{Gold}{rgb}{0.83203125, 0.62109375, 0.05859375}
    
    %these are for hardcopy publishing
    \\setlength{\\oddsidemargin}{-.25in}
    \\setlength{\\textwidth}{6.9in}
    \\setlength{\\topmargin}{-.5in}
    \\setlength{\\textheight}{8.8in}
    
    \\usepackage[pdftex]{hyperref}
    
    \\pagestyle{fancy} \n% with this we ensure that the chapter and section \n% headings are in lowercase. 
    \\renewcommand{\\sectionmark}[1]{\\markright{\\thesection\\ #1}} 
    \\fancyhf{} % delete current setting for header and footer 
    \\fancyhead[LE, RO]{{\\color{Blue}\\bfseries\\thepage}} 
    \\fancyhead[LO]{{\\color{Blue}\\bfseries\\rightmark}} 
    \\fancyhead[RE]{\\bfseries\\leftmark} 
    \\renewcommand{\\headrulewidth}{0.01mm} 
    \\renewcommand{\\footrulewidth}{0pt} 
    \\addtolength{\\headheight}{0.5pt} % make space for the rule 
    \\renewcommand{\\headrule}{{\\color{Gold} 
    \\hrule width\\headwidth height\\headrulewidth \\vskip-\\headrulewidth}}
    \\fancypagestyle{plain}{\n    \\fancyhead{} % get rid of headers on plain pages 
    \\renewcommand{\\headrulewidth}{0pt} % and the line \n} 
    
    \\newcommand{\\Hrule}{{\\color{Gold}\\rule{\\linewidth}{0.01mm}}}
    \\newcommand{\\mytp}{\\thispagestyle{empty}
    \\setlength{\\parindent}{0mm}
    \\setlength{\\parskip}{0mm}
    
    \\begin{center}
{\\includegraphics[width=60mm]{", 
    logo, "}}
    \\end{center}
    
    \\vspace*{\\stretch{1}}
{\\color{Blue}
    \\Hrule\n        \\\\", 
    type, 
    "\n       \\vspace*{\\stretch{.1}}
    \n       \\begin{center}
    \\Huge \n            ", 
    title, "\\\\[4mm]\n       \\end{center}
    
    \\vspace*{\\stretch{.1}}
    \\Hrule
    \\large 
    \\vspace*{\\stretch{2}}
    \\begin{flushright}
    \\large{\n            \\begin{tabular}{rl}\n              & ", 
    date, "\\\\\n", authors1, "
    \\end{tabular}\n        }
    \\end{flushright}\n
    \\begin{center}\n", 
    titlefooter, "\n    \\end{center}\n    } % end Blue \n} % end \\mytp
    \n",
    preamble,
    "\\begin{document}\n\\color{Blue}\n\\mytp\n\\newpage", 
    ifelse(tableofcontents, "\\tableofcontents\n\\newpage", 
           ""), sep = ""))
}



######################################################################
######################################################################
######################################################################
######################################################################


printMod <- function(mod, mod.null = NULL, row.names = NULL, caption = NULL, digits = 3, tex = F, gee.se = 'sandwich',
                     overall.test = F, ci = F, ci.profile = T, level = .95, d.f. = F, cat.cov.test = F, lmer.norm.p = F,
                     csv = NULL, ...){
  ## A function to print regression tables in LaTeX and to csv. 
  ##    Inputs:
  ##       - mod: regression model
  ##       - row.names: a character vector, giving row names for the final printed table
  ##       - caption: a character string, caption passed to latex(...)     
  ##       - digits: number of digits to print
  ##       - tex: logical, should the latex(...) function be run, or should a matrix be returned
  ##       - gee.se: a character string, 'sandwich' or 'naive'
  ##       - overall.test: logical, likelihood ratio / conditional F test for overall model fit
  ##       - ci: logical, should confidence intervals be printed for each parameter
  ##       - ci.profile: logical, should profile likelihood be used for computing confidence intervals
  ##       - level: level of confidence interval, ignored unless ci = T
  ##       - d.f.: logical, should the degress of freedom be printed in the regression table - currently unemplemented
  ##       - cat.cov.test: logical, should categorical covariates be tested with something like ANOVA / LRT
  ##       - lmer.norm.p: logical, should a normal approximation be used for p-values in lmer() models
  ##       - ...: additional parameters passed to latex(...)
  
  ## Cleaning and defining unique model classes
  if(length(class(mod)) == 1){
    mC <- class(mod)
  }
  
  if(length(class(mod)) == 2){
    if(all(class(mod) == c('glm', 'lm'))) mC <- 'glm'
    if(all(class(mod) == c('glmmPQL', 'lme'))) mC <- 'glmmPQL'
    if(all(class(mod) == c('gee', 'glm'))) mC <- 'gee'
  }
  
  if(length(class(mod)) == 3){
    if(all(class(mod) == c('negbin', 'glm', 'lm'))) mC <- 'glm'
  }
  
  if(length(class(mod)) == 4){
    if(all(class(mod) == c('geeglm', 'gee', 'glm', 'lm'))) mC <- 'geeglm'
  }
  
  ## Simple linear models - lm()
  if(mC == 'lm'){
    out <- summary(mod)$coefficients
    out[, 1:3] <- paste('$', formatC(out[, 1:3], format = 'f', digits = digits),
                        '$', sep = '')
    out[, 4] <- pvalFormat(out[, 4])
    colnames(out)[4] <- 'p-value'
    
    if(ci){
      ints <- confint(mod, level = level)
      ints <- paste('($', formatC(ints[, 1], digits = digits, format = 'f'), '$, $', 
                    formatC(ints[, 2], digits = digits, format = 'f'), '$)', sep = '')
      out <- cbind(out[, 1:2], ints, out[, 3:ncol(out)])
      colnames(out)[3] <- paste(round(level * 100), '\\% CI', sep = '')
    }
    
    if(cat.cov.test){
      tt1 <- rep('', nrow(out))
      tt2 <- rep('', nrow(out))
      tAOV <- anova(mod)
      int.cor <- ifelse(rownames(out)[1] == '(Intercept)', 2, 1)
      for(i in which(tAOV$Df[-nrow(tAOV)] > 1)){
        if (i == 1) xx <- 0 else {xx <- sum(tAOV$Df[1:(i - 1)])}
        tt1[xx + int.cor] <- paste('$\\mathcal{F}^{', tAOV[i, 'Df'], '}_{', tAOV[nrow(tAOV), 'Df'], '} = ', formatC(tAOV[i, 'F value'], format = 'f', digits = digits), '$', sep = '')
        tt2[xx + int.cor] <- pvalFormat(tAOV[i, 'Pr(>F)'])
      }
      out <- cbind(out, tt1, tt2)
      colnames(out)[(ncol(out) - 1):ncol(out)] <- c('F value', 'Pr($>$F)')
    }
    
    if(!is.null(mod.null)){
      m_comp <- anova(mod, mod.null)
      out <- cbind(out, c('', paste("$\\mathcal{F}^{", abs(m_comp$Df[2]), '}_{', m_comp$Res.Df[1], '} = ', 
                                    formatC(m_comp$F[2], digits = 3, format = 'f'), '$', sep = ''), rep('', nrow(out) - 2)),
                   c('', pvalFormat(m_comp$`Pr(>F)`[2]), rep('', nrow(out) - 2)))
      colnames(out)[c(ncol(out) - 1, ncol(out))] <- c('ANOVA', 'p-value')
    }
    
    if(overall.test){
      FSTAT <- summary(mod)$fstatistic
      out <- cbind(out, c('', paste('$\\mathcal{F}_{', FSTAT[3], '}^{', 
                                    FSTAT[2], '} = ', formatC(FSTAT[1], format = 'f', digits = 2), 
                                    '$', sep = ''), rep('', nrow(out) - 2)))
      out <- cbind(out, c('', pvalFormat(pf(FSTAT[1], FSTAT[2], FSTAT[3], lower.tail = F)),
                          rep('', nrow(out) - 2)))
      colnames(out)[(ncol(out) - 1):ncol(out)] <- c('Overall F', 'Pr($>$F)')
    }
  }
  
  ## Generalized linear models - glm()
  if(mC == 'glm'){
    fam <- mod$family$family
    if(fam %in% c('binomial', 'quasibinomial')){
      out <- summary(mod)$coefficients
      out[, 1:3] <- paste('$', formatC(as.numeric(out[, 1:3]), format = 'f', digits = digits), '$', sep = '')
      out[, 4]   <- pvalFormat(out[, 4])
      colnames(out)[4] <- 'p-value'
      if(mod$family$link == 'logit'){
        if(ci.profile){ints <- confint(mod, level = level)} else{ints <- confint.default(mod, level = level)}
        CI <- exp(cbind(OR = coef(mod), ints))
        CI <- cbind(paste('$', formatC(CI[, 1], format = 'f', digits = 3), '$', sep = ''),
                    paste('($', formatC(CI[, 2], format = 'f', digits = 3), '$, $',
                          formatC(CI[, 3], format = 'f', digits = 3), '$)', sep = ''))
        out <- cbind(out, CI); out[1, 5:6] <- c('-', '-')
        colnames(out)[5:6] <- c('Odds Ratio', paste(round(level * 100), '\\% CI', sep = ''))
      } else{if(ci){
        if(ci.profile){ints <- confint(mod, level = level)} else{ints <- confint.default(mod, level = level)}
        ints <- paste('($', formatC(ints[, 1], digits = digits, format = 'f'), '$, $', 
                      formatC(ints[, 2], digits = digits, format = 'f'), '$)', sep = '')
        out <- cbind(out[, 1:2], ints, out[, 3:ncol(out)])
        colnames(out)[3] <- paste(round(level * 100), '\\% CI', sep = '')
      }}
    } else{
      out <- summary(mod)$coefficients
      out[, 1:3] <- paste('$', formatC(out[, 1:3], format = 'f', digits = digits),
                          '$', sep = '')
      out[, 4] <- pvalFormat(out[, 4])
      colnames(out)[4] <- 'p-value'
      
      if(ci){
        if(ci.profile){ints <- confint(mod, level = level)} else{ints <- confint.default(mod, level = level)}
        ints <- paste('($', formatC(ints[, 1], digits = digits, format = 'f'), '$, $', 
                      formatC(ints[, 2], digits = digits, format = 'f'), '$)', sep = '')
        out <- cbind(out[, 1:2], ints, out[, 3:ncol(out)])
        colnames(out)[3] <- paste(round(level * 100), '\\% CI', sep = '')
      }
    }
    
    if(cat.cov.test){
      tt1 <- rep('', nrow(out))
      tt2 <- rep('', nrow(out))
      tAOV <- anova(mod, test = 'Chisq')
      int.cor <- ifelse(rownames(out)[1] == '(Intercept)', 2, 1)
      for(i in which(tAOV$Df > 1)){
        tt1[sum(tAOV$Df[1:i], na.rm = T) + int.cor - tAOV$Df[i]] <- paste('$\\chi^2_{', tAOV[i, 'Df'], '} = ', formatC(tAOV[i, 'Deviance'], format = 'f', digits = digits), '$', sep = '')
        tt2[sum(tAOV$Df[1:i], na.rm = T) + int.cor - tAOV$Df[i]] <- pvalFormat(tAOV[i, 'Pr(>Chi)'])
      }
      out <- cbind(out, tt1, tt2)
      colnames(out)[(ncol(out) - 1):ncol(out)] <- c('$\\chi^2$ value', 'Pr($>$$\\chi^2$)')
    }
    
    if(!is.null(mod.null)){
      if(substr(mod$family$family, 0, 17) == 'Negative Binomial'){
        lrt_stat <- abs(mod$deviance - mod.null$deviance)
        out <- cbind(out, c('', paste('$\\chi^2_{', mod.null$df.residual - mod$df.residual, '} = ', formatC(lrt_stat, format = 'f', digits = digits), 
                                      '$', sep = ''), rep('', nrow(out) - 2)))
        out <- cbind(out, c('', pvalFormat(anova(mod, mod.null, test = 'Chisq')$'Pr(Chi)'[2]),
                            rep('', nrow(out) - 2)))
        colnames(out)[c(ncol(out) - 1, ncol(out))] <- c('LRT', 'p-value')
      } else{
        lrt_stat <- abs(mod$deviance - mod.null$deviance)
        out <- cbind(out, c('', paste('$\\chi^2_{', mod.null$df.residual - mod$df.residual, '} = ', formatC(lrt_stat, format = 'f', digits = digits), 
                                      '$', sep = ''), rep('', nrow(out) - 2)))
        out <- cbind(out, c('', pvalFormat(anova(mod, mod.null, test = 'Chisq')$'Pr(>Chi)'[2]),
                            rep('', nrow(out) - 2)))
        colnames(out)[c(ncol(out) - 1, ncol(out))] <- c('$\\Delta$Dev.', 'p-value')
      }
    }
    
    if(overall.test){
      if(substr(mod$family$family, 0, 17) == 'Negative Binomial'){
        LRTSTAT <- with(mod, null.deviance - deviance)
        p.lrt <- anova(update(mod, . ~ 1), mod, test = 'Chisq')[2, 'Pr(Chi)']
        out <- cbind(out, c('', paste('$\\chi^2_{', mod$df.null - mod$df.residual, '} = ', formatC(LRTSTAT, format = 'f', digits = digits), 
                                      '$', sep = ''), rep('', nrow(out) - 2)))
        out <- cbind(out, c('', pvalFormat(p.lrt),
                            rep('', nrow(out) - 2)))
        colnames(out)[(ncol(out) - 1):ncol(out)] <- c('Overall $\\chi^2$', 'Pr($>$$\\chi^2$)')
      } else{
        LRTSTAT <- with(mod, null.deviance - deviance)
        p.lrt <- anova(update(mod, . ~ 1), mod, test = 'Chisq')[2, 'Pr(>Chi)']
        out <- cbind(out, c('', paste('$\\chi^2_{', mod$df.null - mod$df.residual, '} = ', formatC(LRTSTAT, format = 'f', digits = digits), 
                                      '$', sep = ''), rep('', nrow(out) - 2)))
        out <- cbind(out, c('', pvalFormat(p.lrt),
                            rep('', nrow(out) - 2)))
        colnames(out)[(ncol(out) - 1):ncol(out)] <- c('Overall $\\chi^2$', 'Pr($>$$\\chi^2$)')
      }
    }
    
    if(!is.null(row.names)) rownames(out) <- row.names
  }
  
  ## Linear mixed models - lme()
  if(mC == 'lme'){
    out <- summary(mod)$tTable
    out[, c(1, 2, 4)] <- formatC(out[, c(1, 2, 4)], format = 'f', digits = digits)
    out[, 1:4] <- paste('$', out[, 1:4], '$', sep = '')
    out[, 5] <- pvalFormat(out[, 5])
    colnames(out) <- c('Estimate', 'Std. Error', 'DF', 't-value', 'p-value')
    
    if(ci){
      ints <- intervals(mod, level = level, which = 'fixed')$fixed[, c(1, 3)]
      ints <- paste('($', formatC(ints[, 1], digits = digits, format = 'f'), '$, $', 
                    formatC(ints[, 2], digits = digits, format = 'f'), '$)', sep = '')
      out <- cbind(out[, 1:2], ints, out[, 3:ncol(out)])
      colnames(out)[3] <- paste(round(level * 100), '\\% CI', sep = '')
    }
    
    if(cat.cov.test){
      tt1 <- rep('', nrow(out))
      tt2 <- rep('', nrow(out))
      tAOV <- anova(mod)
      int.cor <- ifelse(rownames(out)[1] == '(Intercept)', 1, 1)
      for(i in which(tAOV$numDF > 1)){
        tt1[sum(tAOV$numDF[1:i]) - tAOV$numDF[i] + int.cor] <- paste('$\\mathcal{F}^{', tAOV[i, 'numDF'], '}_{', tAOV[nrow(tAOV), 'denDF'], '} = ', formatC(tAOV[i, 'F-value'], format = 'f', digits = digits), '$', sep = '')
        tt2[sum(tAOV$numDF[1:i]) - tAOV$numDF[i] + int.cor] <- pvalFormat(tAOV[i, 'p-value'])
      }
      out <- cbind(out, tt1, tt2)
      colnames(out)[(ncol(out) - 1):ncol(out)] <- c('F value', 'Pr($>$F)')
    }
    
    if(!is.null(mod.null)){
      lrt_stat <- anova(update(mod, method = 'ML'), update(mod.null, method = 'ML'))
      out <- cbind(out, c('', paste('$\\chi^2_{', abs(diff(lrt_stat$df)), '} = ', formatC(lrt_stat$L.Ratio[2], format = 'f', digits = digits), 
                                    '$', sep = ''), rep('', nrow(out) - 2)))
      out <- cbind(out, c('', pvalFormat(lrt_stat$'p-value'[2]),
                          rep('', nrow(out) - 2)))
      colnames(out)[c(ncol(out) - 1, ncol(out))] <- c('LRT', 'p-value')
    }
    
    if(overall.test){
      LRT <- anova(update(mod, method = 'ML'), update(mod, . ~ 1, method = 'ML'))
      out <- cbind(out, c('', paste('$\\chi^2_{', abs(diff(LRT$df)), '} = ', 
                                    formatC(LRT$L.Ratio[2], format = 'f', digits = 2), '$', sep = ''),
                          rep('', nrow(out) - 2)))
      out <- cbind(out, c('', pvalFormat(LRT$'p-value'[2]),
                          rep('', nrow(out) - 2)))
      colnames(out)[(ncol(out) - 1):ncol(out)] <- c('Overall $\\chi^2$', 'Pr($>$$\\chi^2$)')
    }
    
    if(!d.f.) out <- out[, -which(colnames(out) == 'DF')]
  }
  
  ## Generalised least squares models - gls()
  if(mC == 'gls'){
    out <- summary(mod)$tTable
    out[, c(1:3)] <- formatC(out[, c(1:3)], format = 'f', digits = digits)
    out[, 1:3] <- paste('$', out[, 1:3], '$', sep = '')
    out[, 4] <- pvalFormat(out[, 4])
    colnames(out) <- c('Estimate', 'Std. Error', 't-value', 'p-value')
    
    if(ci){
      ints <- intervals(mod, level = level)$coef[, c(1, 3)]
      ints <- paste('($', formatC(ints[, 1], digits = digits, format = 'f'), '$, $', 
                    formatC(ints[, 2], digits = digits, format = 'f'), '$)', sep = '')
      out <- cbind(out[, 1:2], ints, out[, 3:ncol(out)])
      colnames(out)[3] <- paste(round(level * 100), '\\% CI', sep = '')
    }
    
    if(cat.cov.test){
      tt1 <- rep('', nrow(out))
      tt2 <- rep('', nrow(out))
      tAOV <- anova(mod)
      int.cor <- 1
      for(i in which(tAOV$numDF > 1)){
        tt1[sum(tAOV$numDF[1:i]) + int.cor - tAOV$numDF[i]] <- paste('$\\mathcal{F}^{', tAOV[i, 'numDF'], '}_{', gsub('\n', '', gsub(' ', '', strsplit(attr(tAOV, 'label'), ':')[[1]][2], fixed = T), fixed = T), 
                                                     '} = ', formatC(tAOV[i, 'F-value'], format = 'f', digits = digits), '$', sep = '')
        tt2[sum(tAOV$numDF[1:i]) + int.cor - tAOV$numDF[i]] <- pvalFormat(tAOV[i, 'p-value'])
      }
      out <- cbind(out, tt1, tt2)
      colnames(out)[(ncol(out) - 1):ncol(out)] <- c('F value', 'Pr($>$F)')
    }
    
    if(!is.null(mod.null)){
      lrt_stat <- anova(update(mod, method = 'ML'), update(mod.null, method = 'ML'))
      out <- cbind(out, c('', paste('$\\chi^2_{', abs(diff(lrt_stat$df)), '} = ', formatC(lrt_stat$L.Ratio[2], format = 'f', digits = digits), 
                                    '$', sep = ''), rep('', nrow(out) - 2)))
      out <- cbind(out, c('', pvalFormat(lrt_stat$'p-value'[2]),
                          rep('', nrow(out) - 2)))
      colnames(out)[c(ncol(out) - 1, ncol(out))] <- c('LRT', 'p-value')
    }
    
    if(overall.test){
      LRT <- anova(update(mod, method = 'ML'), update(mod, . ~ 1, method = 'ML'))
      out <- cbind(out, c('', paste('$\\chi^2_{', abs(diff(LRT$df)), '} = ', 
                                    formatC(LRT$L.Ratio[2], format = 'f', digits = 2), '$', sep = ''),
                          rep('', nrow(out) - 2)))
      out <- cbind(out, c('', pvalFormat(LRT$'p-value'[2]),
                          rep('', nrow(out) - 2)))
      colnames(out)[(ncol(out) - 1):ncol(out)] <- c('Overall $\\chi^2$', 'Pr($>\\chi^2$)')
    }
  }
  
  ## Linear mixed models - lmer()
  if(mC %in% c('lmerMod', 'merModLmerTest')){
    if(attr(mC, 'package') == 'lme4'){
      out <- summary(mod)$coefficients
      out.t <- out[, 3]
      out[, c(1:3)] <- formatC(out[, c(1:3)], format = 'f', digits = digits)
      out[, 1:3] <- paste('$', out[, 1:3], '$', sep = '')
      colnames(out) <- c('Estimate', 'Std. Error', 't-value')
      
      if(lmer.norm.p){
        out <- cbind(out, pvalFormat(2 * pnorm(abs(out.t), lower.tail = F)))
        colnames(out)[3:4] <- c('z-value', 'p-value')
      }
      
      if(ci){
        ints <- confint(mod, level = level)
        ints <- ints[-which(substr(rownames(ints), 0, 1) == '.'), ]
        ints <- paste('($', formatC(ints[, 1], digits = digits, format = 'f'), '$, $', 
                      formatC(ints[, 2], digits = digits, format = 'f'), '$)', sep = '')
        out <- cbind(out[, 1:2], ints, out[, 3:ncol(out), drop = F])
        colnames(out)[3] <- paste(round(level * 100), '\\% CI', sep = '')
      }
      
      if(cat.cov.test){
        tt1 <- rep('', nrow(out))
        tt2 <- rep('', nrow(out))
        tAOV <- anova(mod)
        int.cor <- ifelse(rownames(out)[1] == '(Intercept)', 2, 1)
        for(i in which(tAOV$Df > 1)){
          tAOV. <- anova(update(mod, REML = F), update(mod, REML = F, as.formula(paste('. ~ . -', rownames(tAOV)[i]))))
          tt1[sum(tAOV$Df[1:i]) + int.cor - tAOV$Df[i]] <- paste('$\\chi^{2}_{', tAOV.$'Chi Df'[2], 
                                                    '} = ', formatC(tAOV.$Chisq[2], format = 'f', digits = digits), '$', sep = '')
          tt2[sum(tAOV$Df[1:i]) + int.cor - tAOV$Df[i]] <- pvalFormat(tAOV.[2, 'Pr(>Chisq)'])
        }
        out <- cbind(out, tt1, tt2)
        colnames(out)[(ncol(out) - 1):ncol(out)] <- c('$\\chi^2$ value', 'p-value')
      }
      
      if(!is.null(mod.null)){
        lrt_stat <- anova(update(mod, REML = F), update(mod.null, REML = F))
        out <- cbind(out, c('', paste('$\\chi^2_{', abs(diff(lrt_stat$Df)), '} = ', formatC(lrt_stat$Chisq[2], format = 'f', digits = digits), 
                                      '$', sep = ''), rep('', nrow(out) - 2)))
        out <- cbind(out, c('', pvalFormat(lrt_stat$'Pr(>Chisq)'[2]),
                            rep('', nrow(out) - 2)))
        colnames(out)[c(ncol(out) - 1, ncol(out))] <- c('LRT', 'p-value')
      }
      
      if(overall.test){
        LRT <- anova(update(mod, REML = F), update(mod, as.formula(paste('. ~ . - (', paste(rownames(anova(mod)), collapse = ' + '), ')')), REML = F))
        out <- cbind(out, c('', paste('$\\chi^2_{', abs(diff(LRT$Df)), '} = ', 
                                      formatC(LRT$Chisq[2], format = 'f', digits = 2), '$', sep = ''),
                            rep('', nrow(out) - 2)))
        out <- cbind(out, c('', pvalFormat(LRT$'Pr(>Chisq)'[2]),
                            rep('', nrow(out) - 2)))
        colnames(out)[(ncol(out) - 1):ncol(out)] <- c('Overall $\\chi^2$', 'Pr($>\\chi^2$)')
      }
    }
    
    if(attr(mC, 'package') == 'lmerTest'){
      out <- summary(mod)$coefficients[, -3]
      out.t <- out[, 4]
      out[, c(1:3)] <- formatC(out[, c(1:3)], format = 'f', digits = digits)
      out[, 1:3] <- paste('$', out[, 1:3], '$', sep = '')
      out[, 4] <- pvalFormat(out[, 4])
      colnames(out) <- c('Estimate', 'Std. Error', 't-value', 'p-value')
      
      if(lmer.norm.p){
        out[, which(colnames(out) == 'p-value')] <- pvalFormat(2 * pnorm(abs(out.t), lower.tail = F))
        out <- out[, -which(colnames(out) == 'DF')]
        colnames(out)[3:4] <- c('z-value', 'p-value')
      }
      
      if(ci){
        ints <- confint(mod, level = level)
        ints <- ints[-which(substr(rownames(ints), 0, 1) == '.'), ]
        ints <- paste('($', formatC(ints[, 1], digits = digits, format = 'f'), '$, $', 
                      formatC(ints[, 2], digits = digits, format = 'f'), '$)', sep = '')
        out <- cbind(out[, 1:2], ints, out[, 3:ncol(out), drop = F])
        colnames(out)[3] <- paste(round(level * 100), '\\% CI', sep = '')
      }
      
      if(cat.cov.test){
        tt1 <- rep('', nrow(out))
        tt2 <- rep('', nrow(out))
        tAOV <- anova(mod)
        int.cor <- ifelse(rownames(out)[1] == '(Intercept)', 2, 1)
        for(i in which(tAOV$NumDF > 1)){
          tt1[sum(tAOV$NumDF[1:i]) + int.cor - tAOV$NumDF[i]] <- paste('$\\mathcal{F}^{', tAOV[i, 'NumDF'], '}_{', round(tAOV[i, 'DenDF'], digits = 1), 
                                                       '} = ', formatC(tAOV[i, 'F.value'], format = 'f', digits = digits), '$', sep = '')
          tt2[sum(tAOV$NumDF[1:i]) + int.cor - tAOV$NumDF[i]] <- pvalFormat(tAOV[i, 'Pr(>F)'])
        }
        out <- cbind(out, tt1, tt2)
        colnames(out)[(ncol(out) - 1):ncol(out)] <- c('$\\mathcal{F}$ value', 'p-value')
      }
      
      if(!is.null(mod.null)){
        lrt_stat <- anova(update(mod, REML = F), update(mod.null, REML = F))
        out <- cbind(out, c('', paste('$\\chi^2_{', abs(diff(lrt_stat$Df)), '} = ', formatC(lrt_stat$Chisq[2], format = 'f', digits = digits), 
                                      '$', sep = ''), rep('', nrow(out) - 2)))
        out <- cbind(out, c('', pvalFormat(lrt_stat$'Pr(>Chisq)'[2]),
                            rep('', nrow(out) - 2)))
        colnames(out)[c(ncol(out) - 1, ncol(out))] <- c('LRT', 'p-value')
      }
      
      if(overall.test){
        LRT <- anova(update(mod, REML = F), update(mod, as.formula(paste('. ~ . - (', paste(rownames(anova(mod)), collapse = ' + '), ')')), REML = F))
        out <- cbind(out, c('', paste('$\\chi^2_{', abs(diff(LRT$Df)), '} = ', 
                                      formatC(LRT$Chisq[2], format = 'f', digits = 2), '$', sep = ''),
                            rep('', nrow(out) - 2)))
        out <- cbind(out, c('', pvalFormat(LRT$'Pr(>Chisq)'[2]),
                            rep('', nrow(out) - 2)))
        colnames(out)[(ncol(out) - 1):ncol(out)] <- c('Overall $\\chi^2$', 'Pr($>\\chi^2$)')
      }
    }
  }
  
  if(mC == 'glmerMod'){
    out <- summary(mod)$coefficients
    out.t <- out[, 3]
    out[, c(1:3)] <- formatC(out[, c(1:3)], format = 'f', digits = digits)
    out[, 1:3] <- paste('$', out[, 1:3], '$', sep = '')
    out[, 4] <- pvalFormat(out[, 4])
    colnames(out) <- c('Estimate', 'Std. Error', 'z-value', 'p-value')
    
    if(summary(mod)$family == 'binomial'){
      if(summary(mod)$link == 'logit'){
        ccs <- summary(mod)$coefficients
        ints <- cbind(ccs[, 1] - abs(qnorm((1 - level) / 2)) * ccs[, 2], ccs[, 1] + abs(qnorm((1 - level) / 2)) * ccs[, 2])
        CI <- exp(cbind(OR = ccs[, 1], ints))
        CI <- cbind(paste('$', formatC(CI[, 1], format = 'f', digits = 3), '$', sep = ''),
                    paste('($', formatC(CI[, 2], format = 'f', digits = 3), '$, $',
                          formatC(CI[, 3], format = 'f', digits = 3), '$)', sep = ''))
        out <- cbind(out, CI); out[1, 5:6] <- c('-', '-')
        colnames(out)[5:6] <- c('Odds Ratio', paste(round(level * 100), '\\% CI', sep = ''))
      } else {
        if(ci) {
          ccs <- summary(mod)$coefficients
          ints <- cbind(ccs[, 1] - abs(qnorm((1 - level) / 2)) * ccs[, 2], ccs[, 1] + abs(qnorm((1 - level) / 2)) * ccs[, 2])
          ints <- paste('($', formatC(ints[, 1], digits = digits, format = 'f'), '$, $', 
                        formatC(ints[, 2], digits = digits, format = 'f'), '$)', sep = '')
          out <- cbind(out[, 1:2], ints, out[, 3:ncol(out)])
          colnames(out)[3] <- paste(round(level * 100), '\\% CI', sep = '')
        }
      }
    } else {
      if(ci){
        ccs <- summary(mod)$coefficients
        ints <- cbind(ccs[, 1] - abs(qnorm((1 - level) / 2)) * ccs[, 2], ccs[, 1] + abs(qnorm((1 - level) / 2)) * ccs[, 2])
        ints <- paste('($', formatC(ints[, 1], digits = digits, format = 'f'), '$, $', 
                      formatC(ints[, 2], digits = digits, format = 'f'), '$)', sep = '')
        out <- cbind(out[, 1:2], ints, out[, 3:ncol(out), drop = F])
        colnames(out)[3] <- paste(round(level * 100), '\\% CI', sep = '')
      }
    }
    
    if(cat.cov.test){
      tt1 <- rep('', nrow(out))
      tt2 <- rep('', nrow(out))
      tAOV <- anova(mod)
      int.cor <- ifelse(rownames(out)[1] == '(Intercept)', 2, 1)
      for(i in which(tAOV$Df > 1)){
        tAOV. <- anova(update(mod), update(mod, as.formula(paste('. ~ . -', rownames(tAOV)[i]))))
        tt1[sum(tAOV$Df[1:i]) + int.cor - tAOV$Df[i]] <- paste('$\\chi^{2}_{', tAOV.$'Chi Df'[2], 
                                                  '} = ', formatC(tAOV.$Chisq[2], format = 'f', digits = digits), '$', sep = '')
        tt2[sum(tAOV$Df[1:i]) + int.cor - tAOV$Df[i]] <- pvalFormat(tAOV.[2, 'Pr(>Chisq)'])
      }
      out <- cbind(out, tt1, tt2)
      colnames(out)[(ncol(out) - 1):ncol(out)] <- c('$\\chi^2$ value', 'p-value')
    }
    
    if(!is.null(mod.null)){
      lrt_stat <- anova(mod, mod.null)
      out <- cbind(out, c('', paste('$\\chi^2_{', abs(diff(lrt_stat$Df)), '} = ', formatC(lrt_stat$Chisq[2], format = 'f', digits = digits), 
                                    '$', sep = ''), rep('', nrow(out) - 2)))
      out <- cbind(out, c('', pvalFormat(lrt_stat$'Pr(>Chisq)'[2]),
                          rep('', nrow(out) - 2)))
      colnames(out)[c(ncol(out) - 1, ncol(out))] <- c('$\\Delta$Dev.', 'p-value')
    }
    
    if(overall.test){
      LRT <- anova(update(mod), update(mod, as.formula(paste('. ~ . - (', paste(rownames(anova(mod)), collapse = ' + '), ')'))))
      out <- cbind(out, c('', paste('$\\chi^2_{', abs(diff(LRT$Df)), '} = ', 
                                    formatC(LRT$Chisq[2], format = 'f', digits = 2), '$', sep = ''),
                          rep('', nrow(out) - 2)))
      out <- cbind(out, c('', pvalFormat(LRT$'Pr(>Chisq)'[2]),
                          rep('', nrow(out) - 2)))
      colnames(out)[(ncol(out) - 1):ncol(out)] <- c('Overall $\\chi^2$', 'Pr($>$$\\chi^2$)')
    }  
  }
  
  if(mC == 'coxph'){
    out <- summary(mod)$coefficients[, c(1, 3, 4, 5, 2)]
    out[, c(1:3, 5)] <- paste('$', formatC(out[, c(1:3, 5)], format = 'f', digits = digits),
                              '$', sep = '')
    out[, 4] <- pvalFormat(out[, 4])
    ints <- exp(confint(mod, level = level))
    ints <- paste('($', formatC(ints[, 1], digits = digits, format = 'f'), '$, $', 
                  formatC(ints[, 2], digits = digits, format = 'f'), '$)', sep = '')
    out <- cbind(out, ints)
    colnames(out) <- c('Estimate', 'Std. Error', 'z-value', 'p-value', 'Odds Ratio', paste(round(level * 100), '\\% CI', sep = ''))
    
    if(cat.cov.test){
      tt1 <- rep('', nrow(out))
      tt2 <- rep('', nrow(out))
      tAOV <- anova(mod)
      int.cor <- ifelse(rownames(out)[1] == '(Intercept)', 2, 1)
      for(i in which(tAOV$Df > 1)){
        tt1[sum(tAOV$Df[1:i], na.rm = T) + int.cor - tAOV$Df[i]] <- paste('$\\chi^2_{', tAOV[i, 'Df'], '} = ', formatC(tAOV[i, 'Chisq'], format = 'f', digits = digits), '$', sep = '')
        tt2[sum(tAOV$Df[1:i], na.rm = T) + int.cor - tAOV$Df[i]] <- pvalFormat(tAOV[i, 'Pr(>|Chi|)'])
      }
      out <- cbind(out, tt1, tt2)
      colnames(out)[(ncol(out) - 1):ncol(out)] <- c('$\\chi^2$ value', 'Pr($>$$\\chi^2$)')
    }
    
    if(!is.null(mod.null)){
      m_comp <- anova(mod, mod.null)
      out <- cbind(out, c('', paste('$\\chi^2_{', m_comp$Df[2], '} = ', formatC(m_comp$Chisq[2], format = 'f', digits = digits), 
                                    '$', sep = ''), rep('', nrow(out) - 2)))
      out <- cbind(out, c('', pvalFormat(anova(mod, mod.null, test = 'Chisq')$'P(>|Chi|)'[2]),
                          rep('', nrow(out) - 2)))
      colnames(out)[c(ncol(out) - 1, ncol(out))] <- c('LRT', 'p-value')
    }
    
    if(overall.test){
      lrank <- summary(mod)$sctest
      out <- cbind(out, c('', paste('$\\chi^2_{', round(lrank[2], digits = 0), '} = ', formatC(lrank[1], format = 'f', digits = 2), 
                                    '$', sep = ''), rep('', nrow(out) - 2)))
      out <- cbind(out, c('', pvalFormat(lrank[3]),
                          rep('', nrow(out) - 2)))
      colnames(out)[(ncol(out) - 1):ncol(out)] <- c('Score (LR)', 'p-value')
    }
  }
  
  if(mC == 'survreg'){
    out <- summary(mod)$table
    if(rownames(out)[nrow(out)] == 'Log(scale)') out <- out[-nrow(out), ]
    if(colnames(out)[3] == '(Naive SE)') out <- out[, -3]
    nnc <- ncol(out) - 1
    out[, c(1:nnc)] <- paste('$', formatC(out[, c(1:nnc)], format = 'f', digits = digits), '$', sep = '')
    out[, ncol(out)] <- pvalFormat(out[, ncol(out)])
    colnames(out) <- c('Estimate', 'Std. Error', 'z-value', 'p-value')
    
    if(ci){
      ints <- confint(mod, level = level)
      ints <- paste('($', formatC(ints[, 1], digits = digits, format = 'f'), '$, $', 
                    formatC(ints[, 2], digits = digits, format = 'f'), '$)', sep = '')
      out <- cbind(out[, 1:2], ints, out[, 3:ncol(out)])
      colnames(out)[3] <- paste(round(level * 100), '\\% CI', sep = '')
    }
    
    if(cat.cov.test){
      tt1 <- rep('', nrow(out))
      tt2 <- rep('', nrow(out))
      tAOV <- anova(mod)
      int.cor <- ifelse(rownames(out)[1] == '(Intercept)', 2, 1)
      for(i in which(tAOV$Df > 1)){
        tt1[sum(tAOV$Df[1:i], na.rm = T) + int.cor - tAOV$Df[i]] <- paste('$\\chi^2_{', tAOV[i, 'Df'], '} = ', formatC(tAOV[i, 'Deviance'], format = 'f', digits = digits), '$', sep = '')
        tt2[sum(tAOV$Df[1:i], na.rm = T) + int.cor - tAOV$Df[i]] <- pvalFormat(tAOV[i, 'Pr(>Chi)'])
      }
      out <- cbind(out, tt1, tt2)
      colnames(out)[(ncol(out) - 1):ncol(out)] <- c('$\\chi^2$ value', 'Pr($>$$\\chi^2$)')
    }
    
    if(!is.null(mod.null)){
      m_comp <- anova(mod.null, mod)
      out <- cbind(out, c('', paste('$\\chi^2_{', m_comp$Df[2], '} = ', formatC(m_comp$Deviance[2], format = 'f', digits = digits), 
                                    '$', sep = ''), rep('', nrow(out) - 2)))
      out <- cbind(out, c('', pvalFormat(anova(mod, mod.null, test = 'Chisq')$'Pr(>Chi)'[2]),
                          rep('', nrow(out) - 2)))
      colnames(out)[c(ncol(out) - 1, ncol(out))] <- c('LRT', 'p-value')
    }
    
    if(overall.test){
      lrtt <- anova(update(mod, . ~ 1), mod)
      out <- cbind(out, c('', paste('$\\chi^2_{', lrtt$Df[2], '} = ', formatC(lrtt$Deviance[2], format = 'f', digits = 2), 
                                    '$', sep = ''), rep('', nrow(out) - 2)))
      out <- cbind(out, c('', pvalFormat(lrtt$'Pr(>Chi)'[2]),
                          rep('', nrow(out) - 2)))
      colnames(out)[(ncol(out) - 1):ncol(out)] <- c('Overall $\\chi^2$', 'p-value')
    }
  }
  
  if(mC == 'glmmPQL'){
    fam <- mod$family$family
    if(fam %in% c('binomial', 'quasibinomial')){
      out <- summary(mod)$tTable[, -3]
      out[, 1:3] <- paste('$', formatC(as.numeric(out[, 1:3]), format = 'f', digits = digits), '$', sep = '')
      out[, 4]   <- pvalFormat(out[, 4])
      colnames(out)[4] <- 'p-value'
      if(mod$family$link == 'logit'){
        if(ci.profile){ints <- intervals(mod, level = level, which = 'fixed')$fixed[, c(1, 3)]} else{ints <- intervals(mod, level = level, which = 'fixed')[, c(1, 3)]}
        CI <- exp(cbind(OR = summary(mod)$tTable[, 1], ints))
        CI <- cbind(paste('$', formatC(CI[, 1], format = 'f', digits = 3), '$', sep = ''),
                    paste('($', formatC(CI[, 2], format = 'f', digits = 3), '$, $',
                          formatC(CI[, 3], format = 'f', digits = 3), '$)', sep = ''))
        out <- cbind(out, CI); out[1, 5:6] <- c('-', '-')
        colnames(out)[5:6] <- c('Odds Ratio', paste(round(level * 100), '\\% CI', sep = ''))
      } else{if(ci){
        if(ci.profile){ints <- intervals(mod, level = level, which = 'fixed')$fixed[, c(1, 3)]} else{ints <- intervals(mod, level = level, which = 'fixed')[, c(1, 3)]}
        ints <- paste('($', formatC(ints[, 1], digits = digits, format = 'f'), '$, $', 
                      formatC(ints[, 2], digits = digits, format = 'f'), '$)', sep = '')
        out <- cbind(out[, 1:2], ints, out[, 3:ncol(out)])
        colnames(out)[3] <- paste(round(level * 100), '\\% CI', sep = '')
      }}
    } else{
      out <- summary(mod)$tTable[, -3]
      out[, 1:3] <- paste('$', formatC(out[, 1:3], format = 'f', digits = digits),
                          '$', sep = '')
      out[, 4] <- pvalFormat(out[, 4])
      colnames(out)[4] <- 'p-value'
      
      if(ci){
        if(ci.profile){ints <- intervals(mod, level = level, which = 'fixed')$fixed[, c(1, 3)]} else{ints <- intervals(mod, level = level, which = 'fixed')[, c(1, 3)]}
        ints <- paste('($', formatC(ints[, 1], digits = digits, format = 'f'), '$, $', 
                      formatC(ints[, 2], digits = digits, format = 'f'), '$)', sep = '')
        out <- cbind(out[, 1:2], ints, out[, 3:ncol(out)])
        colnames(out)[3] <- paste(round(level * 100), '\\% CI', sep = '')
      }
    }
    
    if(cat.cov.test){
      warning('Categorical covariate tests are unavailable in this function for PQL objects: try a Wald test (package aod).')
    }
    
    if(!is.null(mod.null)){
      warning('Likelihood ratio tests are unavailable in this function for PQL objects.')
    }
    
    if(overall.test){
      warning('Overall fit tests are unavailable in this function for PQL objects.')
    }
    
    if(!is.null(row.names)) rownames(out) <- row.names
  }
  
  if(mC == 'geese'){
    fam <- mod$model$variance
    if(fam %in% c('binomial')){
      out <- as.matrix(summary(mod)$mean)
      out[, 1:3] <- paste('$', formatC(as.numeric(out[, 1:3]), format = 'f', digits = digits), '$', sep = '')
      out[, 4]   <- pvalFormat(out[, 4])
      colnames(out) <- c('Estimate', 'San. SE', 'Wald', 'p-value')
      if(mod$model$mean.link == 'logit'){
        if(ci.profile){ints <- confint(mod, level = level)} else{ints <- confint(mod, level = level)}
        CI <- exp(cbind(OR = as.matrix(summary(mod)$mean)[, 1], ints))
        CI <- cbind(paste('$', formatC(CI[, 1], format = 'f', digits = 3), '$', sep = ''),
                    paste('($', formatC(CI[, 2], format = 'f', digits = 3), '$, $',
                          formatC(CI[, 3], format = 'f', digits = 3), '$)', sep = ''))
        out <- cbind(out, CI); out[1, 5:6] <- c('-', '-')
        colnames(out)[5:6] <- c('Odds Ratio', paste(round(level * 100), '\\% CI', sep = ''))
      } else{if(ci){
        if(ci.profile){ints <- confint(mod, level = level)} else{ints <- confint(mod, level = level)}
        ints <- paste('($', formatC(ints[, 1], digits = digits, format = 'f'), '$, $', 
                      formatC(ints[, 2], digits = digits, format = 'f'), '$)', sep = '')
        out <- cbind(out[, 1:2], ints, out[, 3:ncol(out)])
        colnames(out)[3] <- paste(round(level * 100), '\\% CI', sep = '')
      }}
    } else{
      out <- as.matrix(summary(mod)$mean)
      out[, 1:3] <- paste('$', formatC(out[, 1:3], format = 'f', digits = digits),
                          '$', sep = '')
      out[, 4] <- pvalFormat(out[, 4])
      colnames(out) <- c('Estimate', 'San. SE', 'Wald', 'p-value')
      
      if(ci){
        if(ci.profile){ints <- confint(mod, level = level)} else{ints <- confint(mod, level = level)}
        ints <- paste('($', formatC(ints[, 1], digits = digits, format = 'f'), '$, $', 
                      formatC(ints[, 2], digits = digits, format = 'f'), '$)', sep = '')
        out <- cbind(out[, 1:2], ints, out[, 3:ncol(out)])
        colnames(out)[3] <- paste(round(level * 100), '\\% CI', sep = '')
      }
    }
    
    if(cat.cov.test){
      warning('Categorical covariate tests are unavailable in this function for geese objects: try a Wald test (package aod) or geeglm().')
    }
    
    if(!is.null(mod.null)){
      warning('Likelihood ratio tests are unavailable in this function for geese objects: try geeglm()')
    }
    
    if(overall.test){
      warning('Overall fit tests are unavailable in this function for geese objects: try geeglm()')
    }
    
    if(!is.null(row.names)) rownames(out) <- row.names
  }
  
  if(mC == 'geeglm'){
    fam <- mod$family$family
    if(fam %in% c('binomial')){
      out <- as.matrix(summary(mod)$coefficients)
      out[, 1:3] <- paste('$', formatC(as.numeric(out[, 1:3]), format = 'f', digits = digits), '$', sep = '')
      out[, 4]   <- pvalFormat(out[, 4])
      colnames(out)[c(2, 4)] <- c('San. SE', 'p-value')
      if(mod$family$link == 'logit'){
        if(ci.profile){ints <- confint(mod, level = level)} else{ints <- confint.default(mod, level = level)}
        CI <- exp(cbind(OR = coef(mod), ints))
        CI <- cbind(paste('$', formatC(CI[, 1], format = 'f', digits = 3), '$', sep = ''),
                    paste('($', formatC(CI[, 2], format = 'f', digits = 3), '$, $',
                          formatC(CI[, 3], format = 'f', digits = 3), '$)', sep = ''))
        out <- cbind(out, CI); out[1, 5:6] <- c('-', '-')
        colnames(out)[5:6] <- c('Odds Ratio', paste(round(level * 100), '\\% CI', sep = ''))
      } else{if(ci){
        if(ci.profile){ints <- confint(mod, level = level)} else{ints <- confint.default(mod, level = level)}
        ints <- paste('($', formatC(ints[, 1], digits = digits, format = 'f'), '$, $', 
                      formatC(ints[, 2], digits = digits, format = 'f'), '$)', sep = '')
        out <- cbind(out[, 1:2], ints, out[, 3:ncol(out)])
        colnames(out)[3] <- paste(round(level * 100), '\\% CI', sep = '')
      }}
    } else{
      out <- as.matrix(summary(mod)$coefficients)
      out[, 1:3] <- paste('$', formatC(out[, 1:3], format = 'f', digits = digits),
                          '$', sep = '')
      out[, 4] <- pvalFormat(out[, 4])
      colnames(out)[4] <- 'p-value'
      
      if(ci){
        if(ci.profile){ints <- confint(mod, level = level)} else{ints <- confint.default(mod, level = level)}
        ints <- paste('($', formatC(ints[, 1], digits = digits, format = 'f'), '$, $', 
                      formatC(ints[, 2], digits = digits, format = 'f'), '$)', sep = '')
        out <- cbind(out[, 1:2], ints, out[, 3:ncol(out)])
        colnames(out)[3] <- paste(round(level * 100), '\\% CI', sep = '')
      }
    }
    
    if(cat.cov.test){
      tt1 <- rep('', nrow(out))
      tt2 <- rep('', nrow(out))
      tAOV <- anova(mod, test = 'Chisq')
      int.cor <- ifelse(rownames(out)[1] == '(Intercept)', 2, 1)
      for(i in which(tAOV$Df > 1)){
        tt1[sum(tAOV$Df[1:i], na.rm = T) + int.cor - tAOV$Df[i]] <- paste('$\\chi^2_{', tAOV[i, 'Df'], '} = ', formatC(tAOV[i, 'X2'], format = 'f', digits = digits), '$', sep = '')
        tt2[sum(tAOV$Df[1:i], na.rm = T) + int.cor - tAOV$Df[i]] <- pvalFormat(tAOV[i, 'P(>|Chi|)'])
      }
      out <- cbind(out, tt1, tt2)
      colnames(out)[(ncol(out) - 1):ncol(out)] <- c('$\\chi^2$ value', 'Pr($>$$\\chi^2$)')
    }
    
    if(!is.null(mod.null)){
      lrt_stat <- anova(mod, mod.null)
      out <- cbind(out, c('', paste('$\\chi^2_{', lrt_stat$Df, '} = ', formatC(lrt_stat$X2, format = 'f', digits = digits), 
                                    '$', sep = ''), rep('', nrow(out) - 2)))
      out <- cbind(out, c('', pvalFormat(lrt_stat$'P(>|Chi|)'),
                          rep('', nrow(out) - 2)))
      colnames(out)[c(ncol(out) - 1, ncol(out))] <- c('$\\chi^2$ value', 'p-value')
    }
    
    if(overall.test){
      LRTSTAT <- anova(mod, update(mod, . ~ 1))
      out <- cbind(out, c('', paste('$\\chi^2_{', LRTSTAT$Df, '} = ', formatC(LRTSTAT$X2, format = 'f', digits = digits), 
                                    '$', sep = ''), rep('', nrow(out) - 2)))
      out <- cbind(out, c('', pvalFormat(LRTSTAT$'P(>|Chi|)'),
                          rep('', nrow(out) - 2)))
      colnames(out)[(ncol(out) - 1):ncol(out)] <- c('Overall $\\chi^2$', 'Pr($>$$\\chi^2$)')
    }
    
    if(!is.null(row.names)) rownames(out) <- row.names
  }
  
  if(mC == 'gee'){
    fam <- mod$family$family
    if(fam %in% c('binomial')){
      out <- as.matrix(summary(mod)$coefficients)
      if (gee.se == 'sandwich') out <- out[, c(1, 4, 5)]
      if (gee.se == 'naive') out <- out[, 1:3]
      out <- cbind(out, 2 * pnorm(abs(out[, 3]), lower.tail = FALSE))
      out[, 1:3] <- paste('$', formatC(as.numeric(out[, 1:3]), format = 'f', digits = digits), '$', sep = '')
      out[, 4]   <- pvalFormat(out[, 4])
      colnames(out)[4] <- c('p-value')
      if(mod$family$link == 'logit'){
        if(ci.profile){ints <- confint(mod, level = level, gee.se = gee.se)} else{ints <- confint.default(mod, level = level, gee.se = gee.se)}
        CI <- exp(cbind(OR = coef(mod), ints))
        CI <- cbind(paste('$', formatC(CI[, 1], format = 'f', digits = 3), '$', sep = ''),
                    paste('($', formatC(CI[, 2], format = 'f', digits = 3), '$, $',
                          formatC(CI[, 3], format = 'f', digits = 3), '$)', sep = ''))
        out <- cbind(out, CI); out[1, 5:6] <- c('-', '-')
        colnames(out)[5:6] <- c('Odds Ratio', paste(round(level * 100), '\\% CI', sep = ''))
      } else{if(ci){
        if(ci.profile){ints <- confint(mod, level = level, gee.se = gee.se)} else{ints <- confint.default(mod, level = level, gee.se = gee.se)}
        ints <- paste('($', formatC(ints[, 1], digits = digits, format = 'f'), '$, $', 
                      formatC(ints[, 2], digits = digits, format = 'f'), '$)', sep = '')
        out <- cbind(out[, 1:2], ints, out[, 3:ncol(out)])
        colnames(out)[3] <- paste(round(level * 100), '\\% CI', sep = '')
      }}
    } else{
      out <- as.matrix(summary(mod)$coefficients)
      if (gee.se == 'sandwich') out <- out[, c(1, 4, 5)]
      if (gee.se == 'naive') out <- out[, 1:3]
      out <- cbind(out, 2 * pnorm(abs(out[, 3]), lower.tail = FALSE))
      out[, 1:3] <- paste('$', formatC(as.numeric(out[, 1:3]), format = 'f', digits = digits), '$', sep = '')
      out[, 4]   <- pvalFormat(out[, 4])
      colnames(out)[4] <- c('p-value')
      
      if(ci){
        if(ci.profile){ints <- confint(mod, level = level, gee.se = gee.se)} else{ints <- confint.default(mod, level = level, gee.se = gee.se)}
        ints <- paste('($', formatC(ints[, 1], digits = digits, format = 'f'), '$, $', 
                      formatC(ints[, 2], digits = digits, format = 'f'), '$)', sep = '')
        out <- cbind(out[, 1:2], ints, out[, 3:ncol(out)])
        colnames(out)[3] <- paste(round(level * 100), '\\% CI', sep = '')
      }
    }
    
    if(cat.cov.test){
      warning('Categorical covariate tests are unavailable in this function for gee objects: try a Wald test (package aod) or geepack:geeglm().')
    }
    
    if(!is.null(mod.null)){
      warning('Likelihood ratio tests are unavailable in this function for gee objects: try geepack:geeglm()')
    }
    
    if(overall.test){
      warning('Overall fit tests are unavailable in this function for gee objects: try geepack:geeglm()')
    }
    
    if(!is.null(row.names)) rownames(out) <- row.names
  }
  
  if(!is.null(row.names)) rownames(out) <- row.names
  if(tex){
    latex(out,
          file = '',
          title = '',
          where = '!htp',
          col.just = rep('c', ncol(out)),
          caption = caption,
          insert.bottom = "Significance codes: ***$0.001$, **$0.01$, *$0.05$.",
          ...)
  } else{return(out)}
  if(!is.null(csv)) write.csv(gsub('$', '', out, fixed = T), file = csv, quote = F)
}


######################################################################
######################################################################
######################################################################
######################################################################


lmDiag <- function(x, plot.name = 'diag1.pdf', plot_width = '100mm', 
                   caption = 'Diagnostic plots.', title = NULL){
  if(class(x) == 'lm'){
    cat('{\\footnotesize\n\\begin{verbatim}\n')
    if(!is.null(title)) cat('==', title, '==\n')
    print(summary(x))
    cat('\\end{verbatim}\n')
    pdf(plot.name)
    par(mfrow = c(2, 2))
    plot(x)
    dev.off()
    cat("\\begin{figure}[!htp]\n\\centering\n\\includegraphics[width = ", plot_width, "]{", plot.name,
        "}\n\\caption{", caption, "}\n\\end{figure}}", sep = '')
    cat("\\newpage")
  }
  
  if(class(x) == 'coxph'){
    cat('{\\footnotesize\n\\begin{verbatim}\n')
    if(!is.null(title)) cat('==', title, '==\n')
    print(summary(x))
    cat('\n\n Proportional Hazards test\n')
    print(cox.zph(x))
    cat('\n\\end{verbatim}\n\n}')
  }
  
  if(class(x) == 'lme'){
    cat('{\\footnotesize\n\\begin{verbatim}\n')
    if(!is.null(title)) cat('==', title, '==\n')
    print(summary(x))
    cat('\\end{verbatim}\n')
    pdf(plot.name, height = 4, width = 8)
    print(plot(x), position = c(0, 0, .5, 1), more = T)
    print(qqnorm(x, panel = function(...){
      panel.xyplot(...)
      panel.abline(a = 0, b = 1)}), position = c(.5, 0, 1, 1))
    dev.off()
    cat("\\begin{figure}[!htp]\n\\centering\n\\includegraphics[width = ", plot_width, "]{", plot.name,
        "}\n\\caption{", caption, "}\n\\end{figure}}", sep = '')
    cat("\\newpage")
  }
  
  if(class(x) == 'merModLmerTest'){
  # Temporary! Look into fixing this up
    cat('{\\footnotesize\n\\begin{verbatim}\n')
    if(!is.null(title)) cat('==', title, '==\n')
    print(summary(x))
    cat('\\end{verbatim}\n')
    pdf(plot.name, height = 4, width = 6)
    print(plot(x))
    dev.off()
    cat("\\begin{figure}[!htp]\n\\centering\n\\includegraphics[width = ", plot_width, "]{", plot.name,
        "}\n\\caption{", caption, "}\n\\end{figure}}", sep = '')
    cat("\\newpage")
  }
}


######################################################################
######################################################################
######################################################################
######################################################################


gr = (1 + sqrt(5)) / 2


######################################################################
######################################################################
######################################################################
######################################################################


jFormat <- function(x, digits = 3, format = 'f', CI = NULL, perc = F, ...){
  if(perc){
    out <- paste('$', formatC(x * 100, format = format, digits = digits), '\\\\%$', sep = '')
  } else{
  switch(length(x),
         '1' = {out <- paste('$', formatC(x[1], digits = digits, format = format, ...), '$', sep = '')},
         '2' = {out <- paste('$', formatC(x[1], digits = digits, format = format, ...), '$ ($',
                             formatC(x[2], digits = digits, format = format, ...), '$)', sep = '')},
         '3' = {out <- paste('$', formatC(x[1], digits = digits, format = format, ...), '$ ($',
                             formatC(x[2], digits = digits, format = format, ...), '$, $',
                             formatC(x[3], digits = digits, format = format, ...), '$)', sep = '')})
  if(!is.null(CI)){
    switch(CI,
           '1' = {out <- paste('$', formatC(x[1], digits = digits, format = format, ...), '$, $', 
                               formatC(x[1], digits = digits, format = format, ...), '$', sep = '')},
           '2' = {out <- paste('$', formatC(x[1], digits = digits, format = format, ...), '$ to $', 
                               formatC(x[2], digits = digits, format = format, ...), '$', sep = '')})
  }
    }
  return(out)
}


######################################################################
######################################################################
######################################################################
######################################################################


jReplacer <- function(x, old = NULL, new){
  if(is.null(old)) old = names(table(x))
  if(length(old) > length(new)) new <- rep(new, length(old))
  for(i in 1:length(old)) x[x == old[i]] <- new[i]
  if(class(new) == 'numeric') x <- as.numeric(x)
  return(x)
}


######################################################################
######################################################################
######################################################################
######################################################################


confint.geese <- function(object, level = 0.95, ...) {
  cc <- summary(object)$mean
  mult <- qnorm((1 + level) / 2)
  citab <- with(as.data.frame(cc),
                cbind(lwr = estimate - mult * san.se,
                      upr = estimate + mult * san.se))
  rownames(citab) <- rownames(cc)
  return(citab)
}

confint.geeglm <- function(object, level = 0.95, ...) {
  cc <- summary(object)$coefficients
  mult <- qnorm((1 + level) / 2)
  citab <- with(as.data.frame(cc),
                cbind(lwr = Estimate - mult * Std.err,
                      upr = Estimate + mult * Std.err))
  rownames(citab) <- rownames(cc)
  return(citab)
}

confint.gee <- function(object, level = 0.95, gee.se = gee.se) {
  cc <- data.frame(summary(object)$coefficients)
  mult <- qnorm((1 + level) / 2)
  if (gee.se == 'sandwich') cc$Std.err <- cc$'Robust.S.E.'  
  if (gee.se == 'naive') cc$Std.err <- cc$'Naive.S.E.'
  citab <- with(as.data.frame(cc),
                cbind(lwr = Estimate - mult * Std.err,
                      upr = Estimate + mult * Std.err))
  rownames(citab) <- rownames(cc)
  return(citab)
}
